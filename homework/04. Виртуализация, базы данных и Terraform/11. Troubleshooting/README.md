# Домашнее задание по теме: "Troubleshooting"

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя
- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

**Ответ:**

Список операций для остановки запроса пользователя:

  1. Посмотреть проблемные запросы в БД командой: `db.currentOp({“secs_running”: {$gte: 120}});` (время выполнение запросов >= 120 секунд (т.к. точное время не ясно)).
  2. Определить проблемный запрос (его opid).
  3. Останвить запрос командой: `db.killOp(opid);`.

Нужно учитывать, что данные действия применимы в случаях операций на получение данных. При записи данных подобная остановка операции может нарушить целостность БД.

Так же этот порядок действий возможен если был включен Database Profiler, т.к. по умолчанию он отключен.


Вариант решения проблемы с долгими запросами:

Первое что бы я сделал, это изучил запрос командой .explain("executionStats"), возможно в данных не хватает индекса и его создание устранит данную проблему.

Если же говорить об автоматическом завершении запросов то в запросе можно использовать опцию .maxTimeMS() для установки лимита времени на исполнение запроса. 

## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?
 
**Ответ:**

1) Первичный рост увеличения ключей может происходить в связи с механизмом репликации Redis

2) Блокировка возможна в том случае, если в базе есть не менее 25% ключей срок действия которых истекает в одно и тоже время. Это связано с активным методом отчисти ключей (active way expires). Само по себе такое поведение безвредно, ну и сам факт того, что 25% ключей истекают в одно и то же время довольно необычен.

## Задача 3

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?

**Ответ:**

Данная ошибка означает потерю соединения с сервером и может быть вызвана несколькими проблемами:

1) Проблемы с сетью.
2) Возможно следует увеличить (`connect_timeout`).
3) Возможно следует увеличить максимальный размер данных передаваемых за один запрос (`max_allowed_packet`).

Для локализации необходимо смотреть логи сервера/клиента, использовать tcpdump.

## Задача 4


Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили данную проблему?

**Ответ:**

Основной процесс PostgreSQL был завершен для того, что бы спасти ядро от сбоя (OOM Killer — защитный механизм ядра Linux).

В зависимости от ситуации, возможно требуется добавить оперативной памяти, т.к. для стабильной работы сервера ее уже недостаточно. Или смотреть настройки PostgreSQL, а именно: `shared_buffers`, `temp_buffers`, `work_mem`, `max_connections`, т.к. они влияют на потребление RAM. Для решения данной проблемы желательно, что бы PostgreSQL был на мониторинге (как и все остальное)), что бы понять динамику и причины вызывающие подобное поведение. 
